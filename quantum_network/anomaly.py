"""
Quantum State Anomaly Detection - CbAD integration for quantum state integrity

This module integrates Entruptor's compression-based anomaly detection (CbAD)
to provide real-time quantum state integrity monitoring. This enables detection
of quantum state corruption, decoherence effects, and external interference
in quantum networks.
"""

from __future__ import annotations

import asyncio
import hashlib
import time
import zlib
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Dict, List, Optional, Union

import numpy as np
from rich.console import Console


class AnomalyStatus(Enum):
    """Status of the anomaly detection system."""
    INITIALIZING = "initializing"
    MONITORING = "monitoring"
    ALERT = "alert"
    DEGRADED = "degraded"
    OFFLINE = "offline"


@dataclass
class AnomalyConfig:
    """Configuration for quantum state anomaly detection."""
    sensitivity: float = 0.85  # Detection sensitivity (0.0-1.0)
    window_size: int = 1000   # Analysis window size
    min_compression_ratio: float = 0.1  # Minimum compression ratio threshold
    max_false_positive_rate: float = 0.01  # Maximum false positive rate
    adaptive_thresholds: bool = True
    fusion_enabled: bool = True
    alert_cooldown_sec: float = 60.0
    quantum_state_features: List[str] = None

    def __post_init__(self):
        if self.quantum_state_features is None:
            self.quantum_state_features = [
                "coherence", "fidelity", "entanglement_entropy",
                "phase_stability", "gate_fidelity", "measurement_correlation"
            ]


@dataclass
class QuantumState:
    """Represents a quantum state for anomaly detection."""
    state_id: str
    timestamp: float
    raw_data: bytes
    coherence: float = 0.0
    fidelity: float = 0.0
    entanglement_entropy: float = 0.0
    phase_stability: float = 0.0
    gate_fidelity: float = 0.0
    measurement_correlation: float = 0.0
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class AnomalyDetectionResult:
    """Result of an anomaly detection operation."""
    state_id: str
    timestamp: float
    anomaly_score: float
    confidence: float
    is_anomaly: bool
    detection_method: str
    features_used: List[str]
    processing_time_ms: float
    recommendation: str = ""


@dataclass
class AnomalyAlert:
    """Alert generated by anomaly detection."""
    alert_id: str
    timestamp: float
    severity: str  # "low", "medium", "high", "critical"
    anomaly_score: float
    affected_states: List[str]
    detection_method: str
    description: str
    recommendation: str
    false_positive_probability: float = 0.0


class QuantumStateAnomalyDetector:
    """
    Quantum state anomaly detector using compression-based analysis (CbAD).

    This integrates Entruptor's CbAD technology to provide:
    - Real-time quantum state integrity monitoring
    - Detection of quantum state corruption and decoherence
    - Zero-training anomaly detection for quantum systems
    - Information-theoretic security analysis
    - Adaptive threshold management
    """

    def __init__(self, sensitivity: float = 0.85):
        """Initialize the quantum state anomaly detector."""
        self.config = AnomalyConfig(sensitivity=sensitivity)
        self.console = Console()

        # Detection state
        self.status = AnomalyStatus.INITIALIZING
        self.state_history: List[QuantumState] = []
        self.anomaly_history: List[AnomalyDetectionResult] = []
        self.active_alerts: List[AnomalyAlert] = []

        # Performance metrics
        self.total_states_processed = 0
        self.anomalies_detected = 0
        self.false_positives = 0
        self.true_positives = 0

        # Adaptive thresholds
        self.baseline_compression_ratio = 0.0
        self.adaptive_thresholds = {}
        self.last_alert_time = 0.0

        # CbAD state
        self.cbad_model = {
            'normal_compressibility': 0.0,
            'anomaly_threshold': 0.0,
            'feature_weights': {},
            'historical_patterns': []
        }

    async def initialize(self) -> bool:
        """Initialize the anomaly detection system."""
        try:
            self.console.print("[bold blue]Initializing Quantum State Anomaly Detector...[/bold blue]")
            self.console.print(f"[cyan]Sensitivity: {self.config.sensitivity}[/cyan]")
            self.console.print(f"[cyan]Window size: {self.config.window_size}[/cyan]")

            # Initialize CbAD baseline
            await self._initialize_cbad_baseline()

            # Initialize adaptive thresholds
            if self.config.adaptive_thresholds:
                await self._initialize_adaptive_thresholds()

            self.status = AnomalyStatus.MONITORING
            self.console.print("[green]✓ Quantum state anomaly detector initialized[/green]")

            return True

        except Exception as e:
            self.console.print(f"[red]✗ Anomaly detector initialization failed: {e}[/red]")
            self.status = AnomalyStatus.OFFLINE
            return False

    async def _initialize_cbad_baseline(self):
        """Initialize CbAD baseline from normal quantum states."""
        # Initialize baseline compression characteristics
        self.baseline_compression_ratio = 0.3  # Typical for quantum state data
        self.cbad_model['normal_compressibility'] = self.baseline_compression_ratio
        self.cbad_model['anomaly_threshold'] = 1.0 - self.baseline_compression_ratio

        # Initialize feature weights
        for feature in self.config.quantum_state_features:
            self.cbad_model['feature_weights'][feature] = 1.0 / len(self.config.quantum_state_features)

    async def _initialize_adaptive_thresholds(self):
        """Initialize adaptive thresholds for different quantum state types."""
        for feature in self.config.quantum_state_features:
            self.adaptive_thresholds[feature] = {
                'mean': 0.5,
                'std': 0.1,
                'threshold': 0.8
            }

    async def analyze_state(self, quantum_state: QuantumState) -> AnomalyDetectionResult:
        """
        Analyze a quantum state for anomalies using CbAD.

        Implements compression-based anomaly detection:
        anomaly_score = 1 - (compressed_size / original_size)
        """
        start_time = time.time()

        try:
            # Convert quantum state to byte representation for compression analysis
            state_bytes = self._quantum_state_to_bytes(quantum_state)

            # Apply CbAD compression analysis
            original_size = len(state_bytes)
            compressed_size = len(zlib.compress(state_bytes))
            compression_ratio = compressed_size / original_size

            # Calculate base anomaly score
            base_anomaly_score = 1.0 - compression_ratio

            # Apply feature-specific analysis
            feature_scores = await self._analyze_quantum_features(quantum_state)

            # Fusion analysis (combine compression and feature analysis)
            if self.config.fusion_enabled:
                anomaly_score = self._fuse_anomaly_scores(base_anomaly_score, feature_scores)
            else:
                anomaly_score = base_anomaly_score

            # Apply sensitivity scaling
            anomaly_score = anomaly_score * self.config.sensitivity

            # Determine if this is an anomaly
            is_anomaly = anomaly_score > self.cbad_model['anomaly_threshold']

            # Calculate confidence based on historical performance
            confidence = self._calculate_detection_confidence(anomaly_score, is_anomaly)

            # Generate recommendation
            recommendation = self._generate_recommendation(anomaly_score, is_anomaly, quantum_state)

            result = AnomalyDetectionResult(
                state_id=quantum_state.state_id,
                timestamp=quantum_state.timestamp,
                anomaly_score=anomaly_score,
                confidence=confidence,
                is_anomaly=is_anomaly,
                detection_method="CbAD_Fusion" if self.config.fusion_enabled else "CbAD_Compression",
                features_used=self.config.quantum_state_features,
                processing_time_ms=(time.time() - start_time) * 1000,
                recommendation=recommendation
            )

            # Update state and history
            self.state_history.append(quantum_state)
            self.anomaly_history.append(result)

            # Maintain history size
            if len(self.state_history) > self.config.window_size:
                self.state_history.pop(0)
            if len(self.anomaly_history) > self.config.window_size:
                self.anomaly_history.pop(0)

            # Update metrics
            self.total_states_processed += 1
            if is_anomaly:
                self.anomalies_detected += 1

            # Update adaptive thresholds
            if self.config.adaptive_thresholds:
                await self._update_adaptive_thresholds(quantum_state, anomaly_score)

            return result

        except Exception as e:
            self.console.print(f"[red]✗ State analysis failed: {e}[/red]")
            return AnomalyDetectionResult(
                state_id=quantum_state.state_id,
                timestamp=quantum_state.timestamp,
                anomaly_score=0.0,
                confidence=0.0,
                is_anomaly=False,
                detection_method="Error",
                features_used=[],
                processing_time_ms=(time.time() - start_time) * 1000,
                recommendation="Analysis failed - manual review required"
            )

    def _quantum_state_to_bytes(self, quantum_state: QuantumState) -> bytes:
        """Convert quantum state to byte representation for compression analysis."""
        # Create a deterministic byte representation of the quantum state
        state_dict = {
            'coherence': quantum_state.coherence,
            'fidelity': quantum_state.fidelity,
            'entanglement_entropy': quantum_state.entanglement_entropy,
            'phase_stability': quantum_state.phase_stability,
            'gate_fidelity': quantum_state.gate_fidelity,
            'measurement_correlation': quantum_state.measurement_correlation,
            'raw_data_hash': hashlib.sha256(quantum_state.raw_data).hexdigest() if quantum_state.raw_data else '',
            'metadata': quantum_state.metadata
        }

        import json
        return json.dumps(state_dict, sort_keys=True).encode('utf-8')

    async def _analyze_quantum_features(self, quantum_state: QuantumState) -> Dict[str, float]:
        """Analyze individual quantum state features for anomalies."""
        feature_scores = {}

        for feature in self.config.quantum_state_features:
            feature_value = getattr(quantum_state, feature, 0.0)

            # Get adaptive threshold for this feature
            if feature in self.adaptive_thresholds:
                threshold_info = self.adaptive_thresholds[feature]
                mean_val = threshold_info['mean']
                std_val = threshold_info['std']

                # Calculate z-score
                if std_val > 0:
                    z_score = abs(feature_value - mean_val) / std_val
                    feature_scores[feature] = min(1.0, z_score / 3.0)  # Normalize to 0-1
                else:
                    feature_scores[feature] = 0.0
            else:
                feature_scores[feature] = 0.0

        return feature_scores

    def _fuse_anomaly_scores(self, compression_score: float, feature_scores: Dict[str, float]) -> float:
        """Fuse compression-based and feature-based anomaly scores."""
        # Weighted fusion of different detection methods
        weights = {
            'compression': 0.6,
            'features': 0.4
        }

        # Calculate feature-based score
        if feature_scores:
            feature_score = np.mean(list(feature_scores.values()))
        else:
            feature_score = 0.0

        # Fuse scores
        fused_score = (
            weights['compression'] * compression_score +
            weights['features'] * feature_score
        )

        return min(1.0, fused_score)

    def _calculate_detection_confidence(self, anomaly_score: float, is_anomaly: bool) -> float:
        """Calculate confidence in the anomaly detection result."""
        # Base confidence from anomaly score
        base_confidence = min(1.0, anomaly_score * 2.0)

        # Adjust based on historical performance
        if self.anomaly_history:
            recent_accuracy = self._calculate_recent_accuracy()
            base_confidence *= (0.7 + 0.3 * recent_accuracy)

        return base_confidence

    def _calculate_recent_accuracy(self) -> float:
        """Calculate accuracy of recent anomaly detections."""
        if len(self.anomaly_history) < 10:
            return 0.5  # Default confidence for new systems

        recent_results = self.anomaly_history[-100:]  # Last 100 results
        # Simplified accuracy calculation
        # In practice, this would compare against ground truth
        return 0.85  # Placeholder - would be calculated from validation data

    def _generate_recommendation(self, anomaly_score: float, is_anomaly: bool, quantum_state: QuantumState) -> str:
        """Generate recommendation based on anomaly detection results."""
        if not is_anomaly:
            return "Quantum state appears normal - continue monitoring"

        if anomaly_score > 0.9:
            return "CRITICAL: Immediate quantum state reset recommended - possible decoherence or interference"
        elif anomaly_score > 0.7:
            return "HIGH: Enhanced monitoring recommended - potential quantum state degradation"
        elif anomaly_score > 0.5:
            return "MEDIUM: Review quantum state preparation - possible calibration drift"
        else:
            return "LOW: Monitor closely - minor quantum state variations detected"

    async def _update_adaptive_thresholds(self, quantum_state: QuantumState, anomaly_score: float):
        """Update adaptive thresholds based on new observations."""
        # Update feature thresholds
        for feature in self.config.quantum_state_features:
            feature_value = getattr(quantum_state, feature, 0.0)

            if feature in self.adaptive_thresholds:
                threshold_info = self.adaptive_thresholds[feature]

                # Update running statistics
                alpha = 0.1  # Learning rate
                threshold_info['mean'] = (1 - alpha) * threshold_info['mean'] + alpha * feature_value

                # Update standard deviation
                if len(self.state_history) > 1:
                    feature_values = [getattr(s, feature, 0.0) for s in self.state_history[-100:]]
                    threshold_info['std'] = np.std(feature_values)

                # Update threshold based on anomaly score
                if anomaly_score > 0.5:
                    threshold_info['threshold'] = min(1.0, threshold_info['threshold'] * 1.05)
                else:
                    threshold_info['threshold'] = max(0.1, threshold_info['threshold'] * 0.99)

    async def start_monitoring(self, nodes: Dict[str, Any]) -> bool:
        """Start monitoring quantum states across network nodes."""
        try:
            self.console.print("[bold blue]Starting quantum state monitoring...[/bold blue]")
            self.console.print(f"[cyan]Monitoring {len(nodes)} nodes[/cyan]")

            # Initialize monitoring for each node
            for node_id, node in nodes.items():
                self.console.print(f"[cyan]Setting up monitoring for node {node_id}[/cyan]")

            self.status = AnomalyStatus.MONITORING
            self.console.print("[green]✓ Quantum state monitoring started[/green]")

            return True

        except Exception as e:
            self.console.print(f"[red]✗ Failed to start monitoring: {e}[/red]")
            return False

    async def run_diagnostics(self) -> Dict[str, Any]:
        """Run anomaly detection system diagnostics."""
        diagnostics = {
            "status": self.status.value,
            "total_states_processed": self.total_states_processed,
            "anomalies_detected": self.anomalies_detected,
            "detection_rate": self.anomalies_detected / max(self.total_states_processed, 1),
            "false_positive_rate": self.false_positives / max(self.total_states_processed, 1),
            "true_positive_rate": self.true_positives / max(self.anomalies_detected, 1),
            "average_confidence": np.mean([r.confidence for r in self.anomaly_history[-100:]]) if self.anomaly_history else 0,
            "adaptive_thresholds": self.adaptive_thresholds.copy(),
            "cbad_model_state": self.cbad_model.copy(),
        }

        return diagnostics

    def get_anomaly_report(self) -> Dict[str, Any]:
        """Get comprehensive anomaly detection report."""
        return {
            "detector_status": self.status.value,
            "configuration": {
                "sensitivity": self.config.sensitivity,
                "window_size": self.config.window_size,
                "adaptive_thresholds": self.config.adaptive_thresholds,
                "fusion_enabled": self.config.fusion_enabled,
            },
            "performance_metrics": {
                "total_states_processed": self.total_states_processed,
                "anomalies_detected": self.anomalies_detected,
                "detection_rate": self.anomalies_detected / max(self.total_states_processed, 1),
                "average_confidence": np.mean([r.confidence for r in self.anomaly_history[-100:]]) if self.anomaly_history else 0,
            },
            "recent_anomalies": [
                {
                    "state_id": r.state_id,
                    "timestamp": r.timestamp,
                    "anomaly_score": r.anomaly_score,
                    "confidence": r.confidence,
                    "method": r.detection_method,
                }
                for r in self.anomaly_history[-10:]  # Last 10 results
            ],
            "active_alerts": len(self.active_alerts),
            "diagnostics": asyncio.run(self.run_diagnostics())
        }

    def display_anomaly_status(self) -> None:
        """Display anomaly detection status in formatted table."""
        from rich.table import Table

        table = Table(title="Quantum State Anomaly Detection Status")
        table.add_column("Metric", style="cyan")
        table.add_column("Value", style="green")
        table.add_column("Status", style="yellow")

        report = self.get_anomaly_report()

        table.add_row("Status", report["detector_status"], "✓" if report["detector_status"] == "monitoring" else "⚠")
        table.add_row("States Processed", str(report["performance_metrics"]["total_states_processed"]), "✓")
        table.add_row("Anomalies Detected", str(report["performance_metrics"]["anomalies_detected"]), "⚠" if report["performance_metrics"]["anomalies_detected"] > 0 else "✓")
        table.add_row("Detection Rate", f"{report['performance_metrics']['detection_rate']:.3f}", "⚠" if report["performance_metrics"]["detection_rate"] > 0.1 else "✓")
        table.add_row("Avg Confidence", f"{report['performance_metrics']['average_confidence']:.3f}", "✓" if report["performance_metrics"]["average_confidence"] > 0.8 else "⚠")
        table.add_row("Active Alerts", str(report["active_alerts"]), "⚠" if report["active_alerts"] > 0 else "✓")

        self.console.print(table)