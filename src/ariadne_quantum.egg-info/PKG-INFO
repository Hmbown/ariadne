Metadata-Version: 2.4
Name: ariadne-quantum
Version: 1.0.0
Summary: Ariadne: The Intelligent Quantum Router - Google Maps for Quantum Circuits with Apple Silicon & CUDA acceleration
Author: Shannon Labs
License: Apache-2.0
Keywords: quantum,simulator,qasm3,quantum-computing,apple-silicon,cuda,jax,metal,intelligent-routing,bell-labs,shannon-labs
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: Intended Audience :: Education
Classifier: Intended Audience :: Science/Research
Classifier: License :: OSI Approved :: Apache Software License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Topic :: Scientific/Engineering
Classifier: Topic :: Scientific/Engineering :: Physics
Classifier: Topic :: Education
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Requires-Python: >=3.11
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: qiskit>=2.1.1
Requires-Dist: qiskit-aer>=0.17.2
Requires-Dist: stim>=1.15.0
Requires-Dist: quimb>=1.11.2
Requires-Dist: cotengra>=0.7.5
Requires-Dist: opt_einsum>=3.3
Requires-Dist: mqt.ddsim>=2.0.0
Requires-Dist: numpy>=1.21
Requires-Dist: scipy>=1.7
Requires-Dist: networkx>=3.0
Requires-Dist: matplotlib>=3.5.0
Requires-Dist: pytest>=7.0.0
Provides-Extra: cuda
Requires-Dist: cupy-cuda12x>=12.0.0; extra == "cuda"
Provides-Extra: apple
Requires-Dist: jax>=0.4; (platform_system == "Darwin" and platform_machine == "arm64") and extra == "apple"
Requires-Dist: jaxlib>=0.4; (platform_system == "Darwin" and platform_machine == "arm64") and extra == "apple"
Requires-Dist: jax-metal>=0.1; (platform_system == "Darwin" and platform_machine == "arm64") and extra == "apple"
Provides-Extra: viz
Requires-Dist: matplotlib>=3.5; extra == "viz"
Requires-Dist: seaborn>=0.11; extra == "viz"
Requires-Dist: plotly>=5.0; extra == "viz"
Provides-Extra: dev
Requires-Dist: pytest>=7.0; extra == "dev"
Requires-Dist: pytest-cov>=3.0; extra == "dev"
Requires-Dist: black>=22.0; extra == "dev"
Requires-Dist: isort>=5.10; extra == "dev"
Requires-Dist: pre-commit>=2.17; extra == "dev"
Requires-Dist: mypy>=0.950; extra == "dev"
Provides-Extra: docs
Requires-Dist: sphinx>=5.0; extra == "docs"
Requires-Dist: sphinx-rtd-theme>=1.2; extra == "docs"
Requires-Dist: myst-parser>=0.18; extra == "docs"
Dynamic: license-file

<div align="center">

# Ariadne

### Take Agency Back from the Agents

**Intelligent Quantum Circuit Routing • No ML, Just Math**

[![Python 3.11+](https://img.shields.io/badge/python-3.11+-blue.svg)](https://www.python.org/downloads/)
[![License: Apache 2.0](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)
[![PyPI version](https://badge.fury.io/py/ariadne-quantum.svg)](https://badge.fury.io/py/ariadne-quantum)
[![CI/CD Pipeline](https://github.com/Shannon-Labs/ariadne/actions/workflows/ci.yml/badge.svg)](https://github.com/Shannon-Labs/ariadne/actions/workflows/ci.yml)
[![codecov](https://codecov.io/gh/Shannon-Labs/ariadne/branch/main/graph/badge.svg)](https://codecov.io/gh/Shannon-Labs/ariadne)

*Deterministic quantum routing that automatically selects the optimal backend for your circuits*

[📚 Documentation](https://shannon-labs.github.io/ariadne) • [🚀 Quick Start](#-quick-start) • [📊 Benchmarks](#-benchmarks) • [🤝 Contributing](docs/project/CONTRIBUTING.md)

</div>

---

## 🎯 What is Ariadne?

Ariadne is an **intelligent quantum circuit router** that analyzes your quantum circuits and automatically routes them to the simulator that can actually run them. No machine learning black boxes, no unpredictable agent behavior—just **deterministic mathematical analysis** that makes the right choice every time.

### The Problem
- Qiskit crashes on 30-qubit Clifford circuits that Stim handles effortlessly
- Apple Silicon users miss out on hardware acceleration due to JAX bugs
- Researchers waste time manually choosing between simulators
- Each backend has different strengths, but switching requires rewriting code

### The Solution
```python
from ariadne import simulate

# That's it. Ariadne handles the rest.
result = simulate(your_circuit, shots=1000)
```

**Ariadne automatically:**
- Routes 30-50 qubit Clifford circuits to Stim (no more crashes)
- Accelerates non-Clifford circuits on Apple Silicon with Metal backend
- Falls back gracefully when specialized backends can't handle a circuit
- Provides honest performance metrics and backend selection reasoning

---

## ✨ What's Working Today

| Capability | Impact |
|------------|--------|
| **🧠 Intelligent Routing** | Mathematical analysis of circuit properties (entropy, treewidth, Clifford ratio) automatically selects optimal backend |
| **⚡ Stim Auto-Detection** | Clifford circuits route to Stim without code changes. Run 50-qubit GHZ states in milliseconds |
| **🎨 Metal Apple Silicon** | Hybrid NumPy + Accelerate backend delivers 1.4–1.8× speedups vs CPU on M-series chips |
| **🔄 Zero Configuration** | `simulate(circuit, shots)` just works—no vendor imports or backend selection logic |
| **🔢 Universal Fallback** | Always returns a result, even when specialized backends fail |
| **📋 Open & Extensible** | Apache 2.0 licensed with modular backend interface for community contributions |

### ⚠️ Honest Limitations
- **Beta software**: Verify results for production workloads
- **Small circuit overhead**: For <10 qubits, direct backend calls may be faster due to routing analysis
- **Platform dependencies**: Metal requires macOS 14+ with Python 3.11+; CUDA needs NVIDIA GPU
- **Router learning**: Performance improves as we gather more real-world circuit patterns

---

## 🚀 Quickstart (5 minutes)

```bash
pip install ariadne-quantum
```

### 1. Run a 30-qubit Clifford circuit that crashes plain Qiskit
```python
from ariadne import simulate
from qiskit import QuantumCircuit

qc = QuantumCircuit(30, 30)
qc.h(0)
for i in range(29):
    qc.cx(i, i + 1)
qc.measure_all()

result = simulate(qc, shots=1000)
print("Backend:", result.backend_used)  # -> stim
print("Unique outcomes:", len(result.counts))
```

### 2. Verify Metal acceleration on Apple Silicon
```python
from ariadne.backends.metal_backend import MetalBackend
from qiskit import QuantumCircuit

qc = QuantumCircuit(6, 6)
qc.h(range(6))
for i in range(5):
    qc.cx(i, i + 1)
qc.ry(0.42, 2)
qc.measure_all()

backend = MetalBackend()
counts = backend.simulate(qc, shots=1000)
print("Metal mode:", backend.backend_mode)   # 'metal' on Apple Silicon
print("Execution time (s):", backend.last_summary.execution_time)
```

### 3. Ask the router what it’s thinking
```python
from ariadne import QuantumRouter

router = QuantumRouter()
decision = router.select_optimal_backend(qc)
print(decision)
```

---

## 🔌 Backend support matrix

| Backend | Status | Typical use | Notes |
|---------|--------|-------------|-------|
| **Stim** | ✅ | Clifford / stabilizer circuits | Auto-selected when `is_clifford` is true. Enables >24 qubit circuits. |
| **Metal (Apple Silicon)** | ✅ | Dense non-Clifford circuits up to ~12 qubits | Hybrid NumPy + Accelerate path; 1.4–1.8× faster than CPU baseline. |
| **Qiskit Basic** | ✅ | General fallback | Always available; deterministic counts. |
| **Tensor network (Quimb + Cotengra)** | ✅ | Low treewidth, memory-bound circuits | Exact contraction; slower but handles structured circuits. |
| **DDSIM** | ✅ | Decision diagram simulation | Optional extra backend. |
| **CUDA** | ⚠️ (opt-in) | High-parallel circuits on NVIDIA GPUs | Requires `ariadne.backends.cuda_backend` dependencies and hardware. |

---

## 📊 Benchmarks (September 2025)

### Apple Silicon Metal vs. CPU (`python benchmarks/metal_vs_cpu.py --shots 1000`)

| Circuit archetype | Qiskit CPU (ms) | Ariadne Metal (ms) | Speedup |
|-------------------|-----------------|--------------------|---------|
| Small Clifford (H+CX) | 0.64 | 0.45 | **1.43×** |
| Medium Clifford | 1.05 | 0.63 | **1.66×** |
| Small general (H, CX, RY) | 0.76 | 0.42 | **1.82×** |
| Medium general | 1.15 | 0.68 | **1.67×** |
| Large Clifford | 1.90 | 1.34 | **1.41×** |

Numbers come from `benchmarks/results/metal_benchmark_results.json` on an Apple M4 Max MacBook Pro (Python 3.13, Accelerate-enabled NumPy).

### Router comparison (`python benchmarks/router_comparison.py --shots 256 --repetitions 3`)

| Circuit | Router backend | Router mean (ms) | Direct backend mean (ms) | Notes |
|---------|----------------|------------------|--------------------------|-------|
| ghz_chain_10 | Stim | 17.9 | Stim 9.4 / Qiskit 1.5 | Router overhead dominates tiny circuits. |
| random_clifford_12 | Stim | 339 | Stim 61 / Qiskit 13 | Stim conversion is non-trivial; still required for >24 qubits. |
| random_nonclifford_8 | Tensor network | 111 | Qiskit 1.7 | Exact tensor contraction trades speed for fidelity. |
| qaoa_maxcut_8_p3 | Tensor network | 67.6 | Qiskit 1.3 | Router currently prioritizes accuracy over speed. |
| vqe_ansatz_12 | Tensor network | 68.3 | Qiskit 5.0 | Comparable to raw tensor contraction. |

**Takeaway:** Use Ariadne when you need automatic capability selection or Apple Silicon acceleration. For tiny circuits where you already know the right backend, direct calls remain faster.

---

## 🤝 Who benefits from Ariadne?

- **Researchers & students** exploring quantum error correction, stabilizer codes, or anything Clifford-heavy.
- **Developers** wanting a “just run it” API that chooses between Stim, Metal, tensor networks, and vanilla simulators.
- **Apple Silicon users** who want reproducible speedups without patching JAX themselves.
- **Backend authors** looking to plug their simulator into an open routing framework.

---

## ⚙️ Development setup

```bash
git clone https://github.com/Shannon-Labs/ariadne.git
cd ariadne
pip install -e .[dev]

# Run unit tests
make test

# Apple Silicon benchmarks
python benchmarks/metal_vs_cpu.py --shots 1000 --output results/metal_benchmark_results.json

# Routing comparison benchmarks
python benchmarks/router_comparison.py --shots 256 --repetitions 3
```

> Metal backend tip (Apple Silicon): ensure you are using Python ≥3.10 with the system Accelerate BLAS. If JAX detects only CPU devices, reinstall `jax-metal` from PyPI and restart the Python process.

---

## 🧠 Architecture at a glance

1. **Circuit analysis (`ariadne/route/analyze.py`)** — computes entropy, treewidth, Clifford ratio, two-qubit depth.
2. **Capacity scoring (`QuantumRouter.channel_capacity_match`)** — compares circuit metrics against backend profiles (Stim, Metal, Qiskit, tensor network, DDSIM, CUDA).
3. **Routing decision (`RoutingDecision`)** — returns recommended backend, alternatives, and confidence.
4. **Simulation adapters** — real implementations for Stim, Qiskit Basic, tensor networks, Metal hybrid backend, DDSIM, CUDA.
5. **Unified API** — `ariadne.simulate` and `QuantumRouter` coordinate everything.

The modular backend interface makes it straightforward to contribute new simulators—see `docs/INTEGRATION_GUIDE.md`.

---

## 🔭 Roadmap

- Add optional calibration command to derive backend scores from real benchmarks.
- Further tune routing heuristics to leverage Metal on mixed circuits automatically.
- Nightly CI on Apple Silicon runners.
- Optional GPU kernels for the Tensor Network backend.
- CUDA benchmarking once hardware is available.

Have ideas? Open an issue or a PR—we welcome contributions.

---

## 📄 License

Ariadne is released under the [Apache 2.0 License](LICENSE).

Let us know what you build! Tag @ShannonLabs or open a discussion in the repo. Contributions—from docs fixes to new backends—are warmly welcomed.🌟
